{"version":3,"sources":["entities/task/ui/task-card/styles.module.scss","entities/task/ui/task-row/styles.module.scss","features/toggle-task/model/toggle-task.ts","features/toggle-task/ui.tsx","pages/task-details/styles.module.scss","pages/task-details/index.tsx","entities/task/ui/task-card/index.tsx","entities/task/ui/task-row/index.tsx","shared/config/index.ts","shared/api/typicode/base.ts","shared/api/typicode/tasks.ts","entities/task/model/tasks.ts","entities/task/lib.ts"],"names":["module","exports","toggleTask","createEvent","taskModel","$tasks","on","state","taskId","produce","draft","task","completed","events","ToggleTask","withStatus","selectors","useTask","status","taskLib","getTaskStatus","onClick","toggleTaskModel","checked","TaskDetailsPage","reflect","view","match","isLoading","Number","params","useEffect","effects","getTaskByIdFx","className","styles","root","Content","content","data","size","loading","card","bodyStyle","height","extra","to","actions","title","subTitle","type","bind","$taskDetailsLoading","TaskCard","titleHref","children","cardProps","id","TaskRow","before","cn","getEnvVar","key","undefined","process","Error","API_URL","apiInstance","axios","create","baseURL","BASE_URL","getTasksList","get","getTaskById","setQueryConfig","getTasksListFx","createEffect","typicodeApi","tasks","taskSchema","schema","Entity","normalizeTask","normalize","normalizeTasks","tasksInitialState","createStore","doneData","_","payload","entities","$queryConfig","$tasksListLoading","pending","$tasksList","combine","Object","values","$tasksFiltered","tasksList","config","filter","$tasksListEmpty","map","list","length","useStore"],"mappings":"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","file":"static/js/5.08739a39.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root___dqf0\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__2zmhi\",\"completed\":\"styles_completed__1vJ92\"};","import { createEvent } from \"effector\";\r\nimport produce from \"immer\";\r\n\r\nimport { taskModel } from \"entities/task\";\r\n\r\nconst toggleTask = createEvent<number>();\r\n\r\ntaskModel.$tasks.on(toggleTask, (state, taskId) =>\r\n  produce(state, (draft) => {\r\n    const task = draft[taskId];\r\n    task.completed = !task.completed;\r\n  })\r\n);\r\n\r\nexport const events = { toggleTask };\r\n","import { Checkbox } from \"antd\"; // ~ \"shared/ui/checkbox\"\r\n\r\nimport { taskModel, taskLib } from \"entities/task\";\r\nimport * as toggleTaskModel from './model';\r\n\r\nexport type ToggleTaskProps = {\r\n    taskId: number;\r\n    withStatus?: boolean;\r\n}\r\n\r\n// resolve / unresolve\r\nexport const ToggleTask = ({ taskId, withStatus = true }: ToggleTaskProps) => {\r\n    const task = taskModel.selectors.useTask(taskId);\r\n\r\n    if (!task) return null;\r\n\r\n    const status = taskLib.getTaskStatus(task);\r\n\r\n    return (\r\n        <Checkbox\r\n            onClick={() => toggleTaskModel.events.toggleTask(taskId)}\r\n            checked={task.completed}\r\n        >\r\n            {withStatus && status}\r\n        </Checkbox>\r\n    )\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__TOBA-\",\"content\":\"styles_content__rqowY\",\"card\":\"styles_card__36T7o\"};","import { useEffect } from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport { Layout, Result, Button } from \"antd\"; // ~ \"shared/ui/{...}\"\r\nimport { reflect } from \"@effector/reflect\";\r\n\r\nimport { ToggleTask } from \"features/toggle-task\";\r\nimport { TaskCard, taskModel } from \"entities/task\";\r\nimport styles from \"./styles.module.scss\";\r\n\r\ntype Props = import(\"react-router-dom\").RouteChildrenProps<{\r\n    taskId: string;\r\n}> & {\r\n    isLoading: boolean;\r\n};\r\n\r\nconst View = ({ match, isLoading }: Props) => {\r\n    const taskId = Number(match?.params.taskId);\r\n    const task = taskModel.selectors.useTask(taskId);\r\n\r\n    useEffect(() => {\r\n        taskModel.effects.getTaskByIdFx({ taskId });\r\n    }, [taskId]);\r\n\r\n    // Можно часть логики перенести в entity/task/card (как контейнер)\r\n    if (!task && !isLoading) {\r\n        return (\r\n            <Result \r\n                status=\"404\"\r\n                title=\"404\"\r\n                subTitle=\"Task was not found\"\r\n                extra={<Link to=\"/\"><Button type=\"primary\">Back to tasks list {taskId}</Button></Link>}\r\n            />\r\n        )\r\n    }\r\n\r\n    return (\r\n        <Layout className={styles.root}>\r\n            <Layout.Content className={styles.content}>\r\n                <TaskCard\r\n                    data={task}\r\n                    size=\"default\"\r\n                    loading={isLoading}\r\n                    className={styles.card}\r\n                    bodyStyle={{ height: 400 }}\r\n                    extra={<Link to=\"/\">Back to TasksList</Link>}\r\n                    actions={[\r\n                        <ToggleTask key=\"toggle\" taskId={taskId} />\r\n                    ]}\r\n                />\r\n            </Layout.Content>\r\n        </Layout>\r\n    )\r\n};\r\n\r\n// Использование effector-reflect здесь опционально и некритично в рамках методологии\r\nconst TaskDetailsPage = reflect({\r\n    view: View,\r\n    bind: {\r\n        isLoading: taskModel.$taskDetailsLoading,\r\n    }\r\n});\r\n\r\nexport default TaskDetailsPage;\r\n","import type { PropsWithChildren } from \"react\";\r\nimport { Card } from \"antd\"; // ~ \"shared/ui/card\"\r\nimport { Link } from \"react-router-dom\";\r\nimport styles from \"./styles.module.scss\";\r\n\r\nexport type TaskCardProps = PropsWithChildren<{\r\n    data?: import(\"shared/api\").Task;\r\n    titleHref?: string;\r\n}> & import(\"antd\").CardProps;\r\n\r\nexport const TaskCard = ({ data, titleHref, children, ...cardProps }: TaskCardProps) => {\r\n    // Можно обработать и получше при желании\r\n    if (!data && !cardProps.loading) return null;\r\n\r\n    return (\r\n        <Card\r\n            // Можно обработать и получше при желании\r\n            title={`Task#${cardProps.loading ? \"\" : data?.id}`}\r\n            className={styles.root}\r\n            {...cardProps}\r\n        >\r\n            {titleHref ? <Link to={titleHref}>{data?.title}</Link> : data?.title}\r\n            {children}\r\n        </Card>\r\n    );\r\n};\r\n","import type { PropsWithChildren, ReactNode } from \"react\";\r\nimport cn from \"classnames\"; // Можно смело использовать аналоги\r\nimport { Row } from \"antd\"; // ~ \"shared/ui/row\"\r\nimport { Link } from \"react-router-dom\";\r\nimport styles from \"./styles.module.scss\";\r\n\r\nexport type TaskRowProps = PropsWithChildren<{\r\n  data: import(\"shared/api\").Task;\r\n  titleHref?: string;\r\n  before?: ReactNode;\r\n}>;\r\n\r\nexport const TaskRow = ({ data, before, titleHref }: TaskRowProps) => {\r\n  const title = titleHref ? <Link to={\"/payments\"}>Payments</Link> : data.title;\r\n\r\n  return (\r\n    // Можно смело использовать classnames и аналоги\r\n    <Row className={cn(styles.root, { [styles.completed]: data.completed })}>\r\n      {before}\r\n      {title}\r\n    </Row>\r\n  );\r\n};\r\n","/**\r\n * Модуль инициализации env-переменных\r\n * @remark Если не найдено значение хоть одной переменной,\r\n * Приложение сразу выбросит ошибку, при инициализации модуля\r\n * @module\r\n */\r\n\r\n/**\r\n * Получение env-переменной\r\n * @throwable\r\n */\r\n const getEnvVar = (key: string) => {\r\n    if (process.env[key] === undefined) {\r\n        throw new Error(`Env variable ${key} is required`);\r\n    }\r\n    return process.env[key] || \"\";\r\n};\r\n\r\n/** API entrypoint */\r\nexport const API_URL = getEnvVar(\"REACT_APP_API_URL\");\r\n\r\n/** Режим запуска программы */\r\nexport const NODE_ENV = getEnvVar(\"NODE_ENV\");\r\n/** Режим разработки */\r\nexport const isDevEnv = NODE_ENV === \"development\";\r\n/** Режим продакшена */\r\nexport const isProdEnv = NODE_ENV === \"production\";\r\n","import axios from \"axios\";\r\nimport { API_URL } from \"shared/config\";\r\n\r\n// Потенциально, можно передавать accessToken\r\nexport const apiInstance = axios.create({\r\n    baseURL: API_URL\r\n});\r\n","import type { AxiosPromise } from \"axios\";\r\nimport { apiInstance } from \"./base\";\r\nimport type { Task } from \"./models\";\r\n\r\nconst BASE_URL = \"/todos\"\r\n\r\nexport type GetTasksListParams = {\r\n    userId?: number;\r\n    completed?: boolean;\r\n};\r\n\r\nexport const getTasksList = (params?: GetTasksListParams): AxiosPromise<Task[]> => {\r\n    return apiInstance.get(BASE_URL, { params });\r\n};\r\n\r\nexport type GetTaskByIdParams = {\r\n    taskId: number;\r\n    [x: string]: any;\r\n};\r\n\r\nexport const getTaskById = ({ taskId, ...params }: GetTaskByIdParams): AxiosPromise<Task> => {\r\n    return apiInstance.get(`${BASE_URL}/${taskId}`, { params });\r\n};\r\n","import { createStore, combine, createEffect, createEvent } from \"effector\";\r\nimport { useStore } from \"effector-react\";\r\nimport { normalize, schema } from \"normalizr\";\r\n\r\nimport { typicodeApi } from \"shared/api\";\r\nimport type { Task } from \"shared/api\";\r\n\r\nexport type QueryConfig = {\r\n  completed?: boolean;\r\n  userId?: number;\r\n};\r\n\r\n\r\nconst setQueryConfig = createEvent<QueryConfig>();\r\n\r\n\r\n// В каждом эффекте так же может быть своя доп. обработка\r\nconst getTasksListFx = createEffect((params?: typicodeApi.tasks.GetTasksListParams) => {\r\n  return typicodeApi.tasks.getTasksList(params);\r\n});\r\nconst getTaskByIdFx = createEffect((params: typicodeApi.tasks.GetTaskByIdParams) => {\r\n  return typicodeApi.tasks.getTaskById(params);\r\n});\r\n\r\n\r\n// Можно вынести нормализацию на уровне API\r\nexport const taskSchema = new schema.Entity(\"tasks\");\r\nexport const normalizeTask = (data: Task) => normalize(data, taskSchema);\r\nexport const normalizeTasks = (data: Task[]) => normalize(data, [taskSchema]);\r\n\r\n\r\n// В рамках демо некритично, но можно хранить и в виде массива без нормализации\r\nexport const tasksInitialState: Record<number, Task> = {};\r\nexport const $tasks = createStore(tasksInitialState)\r\n  .on(getTasksListFx.doneData, (_, payload) => normalizeTasks(payload.data).entities.tasks)\r\n  .on(getTaskByIdFx.doneData, (state, payload) => ({\r\n    ...state,\r\n    ...normalizeTask(payload.data).entities.tasks,\r\n  }))\r\n\r\n\r\n// Можно вынести в отдельную директорию (для хранения нескольких моделей)\r\nexport const $queryConfig = createStore<QueryConfig>({})\r\n  .on(setQueryConfig, (_, payload) => payload)\r\n\r\n// Можно добавить потенциально debounce логику\r\nexport const $tasksListLoading = getTasksListFx.pending;\r\nexport const $taskDetailsLoading = getTaskByIdFx.pending;\r\n\r\n\r\n/**\r\n * \"Список\" задач\r\n */\r\nexport const $tasksList = combine($tasks, (tasks) => Object.values(tasks));\r\n\r\n/**\r\n * Отфильтрованные таски\r\n * @remark Можно разруливать на уровне эффектов - но тогда нужно подключать дополнительную логику в стор\r\n * > Например скрывать/показывать таск при `toggleTask` событии\r\n */\r\nexport const $tasksFiltered = combine(\r\n  $tasksList,\r\n  $queryConfig,\r\n  (tasksList, config) => {\r\n    return tasksList.filter(task => (\r\n      config.completed === undefined ||\r\n      task.completed === config.completed\r\n  ))},\r\n);\r\n\r\nexport const $tasksListEmpty = $tasksFiltered.map((list) => list.length === 0);\r\n\r\n// При желании можно завести отдельный селектор, не завязанный на react биндинги\r\nconst useTask = (taskId: number): import(\"shared/api\").Task | undefined => {\r\n  return useStore($tasks)[taskId];\r\n};\r\n\r\nexport const events = { setQueryConfig };\r\n\r\nexport const effects = {\r\n  getTaskByIdFx,\r\n  getTasksListFx,\r\n};\r\n\r\nexport const selectors = {\r\n  useTask,\r\n};\r\n","import type { Task } from \"shared/api\";\r\n\r\nexport const getTaskStatus = (data: Task) => {\r\n    return data.completed ? \"CLOSED\" : \"OPENED\";\r\n};\r\n"],"sourceRoot":""}